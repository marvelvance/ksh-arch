
/* : : generated by proto : : */
/***********************************************************************
*                                                                      *
*               This software is part of the ast package               *
*          Copyright (c) 1982-2013 AT&T Intellectual Property          *
*                      and is licensed under the                       *
*                 Eclipse Public License, Version 1.0                  *
*                    by AT&T Intellectual Property                     *
*                                                                      *
*                A copy of the License is available at                 *
*          http://www.eclipse.org/org/documents/epl-v10.html           *
*         (with md5 checksum b35adb5213ca9657e911e9befb180842)         *
*                                                                      *
*              Information and Software Systems Research               *
*                            AT&T Research                             *
*                           Florham Park NJ                            *
*                                                                      *
*                    David Korn <dgkorn@gmail.com>                     *
*                                                                      *
***********************************************************************/
                  
#ifndef SH_INTERACTIVE
#if !defined(__PROTO__)
#include <prototyped.h>
#endif
#if !defined(__LINKAGE__)
#define __LINKAGE__		/* 2004-08-11 transition */
#endif

/*
 * David Korn
 * AT&T Labs
 *
 * Interface definitions for shell command language
 *
 */

#define SH_VERSION	20120720

#include	<ast.h>
#include	<cdt.h>
#include	<stk.h>
#ifdef _SH_PRIVATE
#   include	"name.h"
#else
#   include	<nval.h>
#endif /* _SH_PRIVATE */
#if __STDC_VERSION__ >= 199901L
#    include	<stdint.h>
#endif

#undef NOT_USED
#define NOT_USED(x)	(&(x),1)

/* options */
#if __STDC_VERSION__ >= 199901L
    typedef uint_fast64_t Shopt_t_data_t;
#else
    typedef unsigned int Shopt_t_data_t;
#endif
typedef struct
{
	Shopt_t_data_t v[(256/8)/sizeof(Shopt_t_data_t)];
}
Shopt_t;

typedef struct Shell_s Shell_t;

#include	<shcmd.h>

typedef void	(*Shinit_f) __PROTO__((Shell_t*, int));
#ifndef SH_wait_f_defined
    typedef int	(*Shwait_f) __PROTO__((int, long, int));
#   define SH_wait_f_defined
#endif

union Shnode_u;
typedef union Shnode_u Shnode_t;

#define SH_CFLAG	0
#define SH_HISTORY	1	/* used also as a state */
#define	SH_ERREXIT	2	/* used also as a state */
#define	SH_VERBOSE	3	/* used also as a state */
#define SH_MONITOR	4	/* used also as a state */
#define	SH_INTERACTIVE	5	/* used also as a state */
#define	SH_RESTRICTED	6
#define	SH_XTRACE	7
#define	SH_KEYWORD	8
#define SH_NOUNSET	9
#define SH_NOGLOB	10
#define SH_ALLEXPORT	11
#define SH_PFSH		12
#define SH_IGNOREEOF	13
#define SH_NOCLOBBER	14
#define SH_MARKDIRS	15
#define SH_BGNICE	16
#define SH_VI		17
#define SH_VIRAW	18
#define	SH_TFLAG	19
#define SH_TRACKALL	20
#define	SH_SFLAG	21
#define	SH_NOEXEC	22
#define SH_GMACS	24
#define SH_EMACS	25
#define SH_PRIVILEGED	26
#define SH_SUBSHARE	27	/* subshell shares state with parent */
#define SH_NOLOG	28
#define SH_NOTIFY	29
#define SH_DICTIONARY	30
#define SH_PIPEFAIL	32
#define SH_GLOBSTARS	33
#define SH_XARGS	34
#define SH_RC		35
#define SH_SHOWME	36
#define SH_LETOCTAL	37

/*
 * passed as flags to builtins in Nambltin_t struct when BLT_OPTIM is on
 */
#define SH_BEGIN_OPTIM	0x1
#define SH_END_OPTIM	0x2

/* The following type is used for error messages */

/* error messages */
extern __MANGLE__ const char	e_defpath[];
extern __MANGLE__ const char	e_found[];
extern __MANGLE__ const char	e_nospace[];
extern __MANGLE__ const char	e_format[];
extern __MANGLE__ const char 	e_number[];
extern __MANGLE__ const char	e_restricted[];
extern __MANGLE__ const char	e_recursive[];
extern __MANGLE__ char		e_version[];

typedef struct sh_scope
{
	struct sh_scope	*par_scope;
	int		argc;
	char		**argv;
	char		*cmdname;
	char		*filename;
	char		*funname;
	int64_t		lineno;
	Dt_t		*var_tree;
	struct sh_scope	*self;
} Shscope_t;

/*
 * Saves the state of the shell
 */

struct Shell_s
{
	Shopt_t		options;	/* set -o options */
	Dt_t		*var_tree;	/* for shell variables */
	Dt_t		*fun_tree;	/* for shell functions */
	Dt_t		*alias_tree;	/* for alias names */
	Dt_t		*bltin_tree;    /* for builtin commands */
	Shscope_t	*topscope;	/* pointer to top-level scope */
	int		inlineno;	/* line number of current input file */
	int		exitval;	/* most recent exit value */
	unsigned char	trapnote;	/* set when trap/signal is pending */
	char		shcomp;		/* set when runing shcomp */
	short		subshell;	/* set for virtual subshell */
	Stk_t		*stk;		/* stack poiter */
	int		pwdfd;		/* file descriptor for pwd */
#ifdef _SH_PRIVATE
	_SH_PRIVATE
#endif /* _SH_PRIVATE */
};

/* flags for sh_parse */
#define SH_NL		1	/* Treat new-lines as ; */
#define SH_EOF		2	/* EOF causes syntax error */

/* symbolic values for sh_iogetiop */
#define SH_IOCOPROCESS	(-2)
#define SH_IOHISTFILE	(-3)

#include	<cmd.h>

/* symbolic value for sh_fdnotify */
#define SH_FDCLOSE	(-1)

#undef getenv			/* -lshell provides its own */

#if defined(__EXPORT__) && defined(_DLL)
#   ifdef _BLD_shell
#undef __MANGLE__
#define __MANGLE__ __LINKAGE__ __EXPORT__
#   endif /* _BLD_shell */
#endif /* _DLL */

extern __MANGLE__ int		sh_access __PROTO__((const char*,int));
extern __MANGLE__ Namval_t		*sh_addbuiltin __PROTO__((const char*, int(*)(int, char*[],Shbltin_t*), __V_*));
extern __MANGLE__ Dt_t		*sh_bltin_tree __PROTO__((void));
extern __MANGLE__ int		sh_chdir __PROTO__((const char*));
extern __MANGLE__ int 		sh_close __PROTO__((int));
extern __MANGLE__ void 		sh_delay __PROTO__((double));
extern __MANGLE__ int 		sh_dup __PROTO__((int));
extern __MANGLE__ int 		sh_eval __PROTO__((Sfio_t*,int));
extern __MANGLE__ int		sh_exec __PROTO__((Shell_t*,const Shnode_t*,int));
extern __MANGLE__ void 		sh_exit __PROTO__((int));
extern __MANGLE__ int		sh_fchdir __PROTO__((int));
extern __MANGLE__ int		sh_fcntl __PROTO__((int, int, ...));
extern __MANGLE__ Sfio_t		*sh_fd2sfio __PROTO__((int));
extern __MANGLE__ int		(*sh_fdnotify __PROTO__((int(*)(int,int)))) __PROTO__((int,int));
extern __MANGLE__ char		*sh_fmtq __PROTO__((const char*));
extern __MANGLE__ char		*sh_fmtqf __PROTO__((const char*, int, int));
extern __MANGLE__ int 		sh_fun __PROTO__((Namval_t*,Namval_t*, char*[]));
extern __MANGLE__ int 		sh_funscope __PROTO__((int,char*[],int(*)(__V_*),__V_*,int));
extern __MANGLE__ Shell_t		*sh_getinterp __PROTO__((void));
extern __MANGLE__ Shscope_t	*sh_getscope __PROTO__((int,int));
extern __MANGLE__ Shell_t		*sh_init __PROTO__((int,char*[],Shinit_f));
extern __MANGLE__ Sfio_t		*sh_iogetiop __PROTO__((int,int));
extern __MANGLE__ int		sh_main __PROTO__((int, char*[], Shinit_f));
extern __MANGLE__ void		sh_menu __PROTO__((Sfio_t*, int, char*[]));
extern __MANGLE__ void		sh_offoption __PROTO__((int));
extern __MANGLE__ bool		sh_isoption __PROTO__((int));
extern __MANGLE__ void		sh_onoption __PROTO__((int));
extern __MANGLE__ int		sh_open __PROTO__((const char*, int, ...));
extern __MANGLE__ int		sh_openmax __PROTO__((void));
extern __MANGLE__ __V_		*sh_parse __PROTO__((Shell_t*, Sfio_t*,int));
extern __MANGLE__ Sfio_t		*sh_pathopen __PROTO__((const char*));
extern __MANGLE__ int 		sh_pipe __PROTO__((int[]));
extern __MANGLE__ ssize_t 		sh_read __PROTO__((int, __V_*, size_t));
extern __MANGLE__ int		sh_reinit __PROTO__((char*[]));
extern __MANGLE__ int		sh_run __PROTO__((int, char*[]));
extern __MANGLE__ off_t		sh_seek __PROTO__((int, off_t, int));
extern __MANGLE__ Shscope_t	*sh_setscope __PROTO__((Shscope_t*));
extern __MANGLE__ void		sh_sigcheck __PROTO__((Shell_t*));
extern __MANGLE__ int		sh_stat __PROTO__((const char*,struct stat*));
extern __MANGLE__ Sfdouble_t	sh_strnum __PROTO__((const char*, char**, int));
extern __MANGLE__ void		sh_subfork __PROTO__((void));
extern __MANGLE__ int 		sh_trap __PROTO__((const char*,int));
extern __MANGLE__ mode_t 		sh_umask __PROTO__((mode_t));
extern __MANGLE__ __V_		*sh_waitnotify __PROTO__((Shwait_f));
extern __MANGLE__ int 		sh_waitsafe __PROTO__((void));
extern __MANGLE__ ssize_t 		sh_write __PROTO__((int, const __V_*, size_t));

extern __MANGLE__ Namval_t		*sh_addbuiltin_20120720 __PROTO__((Shell_t*,const char*, int(*)(int, char*[],Shbltin_t*), __V_*));
extern __MANGLE__ Dt_t		*sh_bltin_tree_20120720 __PROTO__((Shell_t*));
extern __MANGLE__ int 		sh_eval_20120720 __PROTO__((Shell_t*,Sfio_t*,int));
extern __MANGLE__ void 		sh_exit_20120720 __PROTO__((Shell_t*,int));
extern __MANGLE__ Sfio_t		*sh_fd2sfio_20120720 __PROTO__((Shell_t*,int));
extern __MANGLE__ int 		sh_fun_20120720 __PROTO__((Shell_t*,Namval_t*,Namval_t*, char*[]));
extern __MANGLE__ int 		sh_funscope_20120720 __PROTO__((Shell_t*,int,char*[],int(*)(__V_*),__V_*,int));
extern __MANGLE__ Shscope_t	*sh_getscope_20120720 __PROTO__((Shell_t*,int,int));
extern __MANGLE__ void		sh_offoption_20120720 __PROTO__((Shell_t*,int));
extern __MANGLE__ bool		sh_isoption_20120720 __PROTO__((Shell_t*,int));
extern __MANGLE__ void		sh_onoption_20120720 __PROTO__((Shell_t*,int));
extern __MANGLE__ void		sh_menu_20120720 __PROTO__((Shell_t *,Sfio_t*, int, char*[]));
extern __MANGLE__ Sfio_t		*sh_pathopen_20120720 __PROTO__((Shell_t*,const char*));
extern __MANGLE__ int		sh_reinit_20120720 __PROTO__((Shell_t*,char*[]));
extern __MANGLE__ int		sh_run_20120720 __PROTO__((Shell_t*,int, char*[]));
extern __MANGLE__ Shscope_t	*sh_setscope_20120720 __PROTO__((Shell_t*,Shscope_t*));
extern __MANGLE__ Sfdouble_t	sh_strnum_20120720 __PROTO__((Shell_t*,const char*, char**,int));
extern __MANGLE__ int 		sh_trap_20120720 __PROTO__((Shell_t*,const char*,int));
extern __MANGLE__ __V_		*sh_waitnotify_20120720 __PROTO__((Shwait_f,__V_*));

#define sh_ptr(np)	((np)->nvshell)

/*
 * direct access to sh is obsolete, use sh_getinterp() instead
 */
#if !defined(_SH_PRIVATE) && defined(__IMPORT__) && !defined(_BLD_shell)
	extern __MANGLE__ __IMPORT__  Shell_t sh;
#else
	extern __MANGLE__ Shell_t sh;
#endif

#include	<shellapi.h>

#ifdef _DLL
#undef __MANGLE__
#define __MANGLE__ __LINKAGE__
#endif /* _DLL */

#ifndef _AST_INTERCEPT
#   if _lib_lseek64
#       undef  stat64
#	define stat64(a,b)	sh_stat(a,b)	
#   else
#       undef  stat
#	define stat(a,b)	sh_stat(a,b)	
#   endif
#endif /* !_AST_INTERCEPT */
#ifndef _shtest_c
#   ifndef _SH_PRIVATE
#       undef  access
#	define access(a,b)	sh_access(a,b)
#   endif
#endif /* !_shtest_c */
#ifndef _shio_h
#ifndef _AST_INTERCEPT
#   undef  chdir
#   define chdir(a)		sh_chdir(a)	
#   undef  fchdir
#   define fchdir(a)		sh_fchdir(a)
#endif
#   ifndef HIST_MAX
#       if _lib_lseek64
#           undef  open64
#           define open64	sh_open
#           undef  lseek64
#           define lseek64(a,b,c)	sh_seek(a,b,c)
#       else
#           undef  open
#           define open		sh_open
#           undef  lseek
#           define lseek(a,b,c)	sh_seek(a,b,c)
#       endif
#   endif
#   ifndef _SH_PRIVATE
#       undef  access
#       define access(a,b)	sh_access(a,b)
#       undef  close
#       define close(a)		sh_close(a)
#       if SHELLAPI(20120720)
#           undef  exit
#           define exit(a)	sh_exit(sh_getinterp(),a)
#       else
#           undef  exit
#           define exit(a)	sh_exit(a)
#       endif
#       undef  fcntl
#       define fcntl(a,b,c)	sh_fcntl(a,b,c)
#       undef  pipe
#       define pipe(a)		sh_pipe(a)
#       undef  read
#       define read(a,b,c)	sh_read(a,b,c)
#       undef  write
#       define write(a,b,c)	sh_write(a,b,c)
#       undef  umask
#       define umask(a)		sh_umask(a)
#       undef  dup
#       define dup		sh_dup
#   endif /* !_SH_PRIVATE */
#endif /* !_shio_h */

#define SH_SIGSET	4
#define SH_EXITSIG	0400	/* signal exit bit */
#define SH_EXITMASK	(SH_EXITSIG-1)	/* normal exit status bits */
#define SH_RUNPROG	-1022	/* needs to be negative and < 256 */

#endif /* SH_INTERACTIVE */
