const char bash_pre_rc[] = 
"########################################################################\n"
"#                                                                      #\n"
"#               This software is part of the ast package               #\n"
"#          Copyright (c) 1982-2014 AT&T Intellectual Property          #\n"
"#                      and is licensed under the                       #\n"
"#                 Eclipse Public License, Version 1.0                  #\n"
"#                    by AT&T Intellectual Property                     #\n"
"#                                                                      #\n"
"#                A copy of the License is available at                 #\n"
"#          http://www.eclipse.org/org/documents/epl-v10.html           #\n"
"#         (with md5 checksum b35adb5213ca9657e911e9befb180842)         #\n"
"#                                                                      #\n"
"#              Information and Software Systems Research               #\n"
"#                            AT&T Research                             #\n"
"#                           Florham Park NJ                            #\n"
"#                                                                      #\n"
"#                    David Korn <dgkorn@gmail.com>                     #\n"
"#                                                                      #\n"
"########################################################################\n"
"#\n"
"# bash compatibility startup script\n"
"#\n"
"# Author:\n"
"# Karsten Fleischer\n"
"# Omnium Software Engineering\n"
"# An der Luisenburg 7\n"
"# D-51379 Leverkusen\n"
"# Germany\n"
"#\n"
"# <K.Fleischer@omnium.de>\n"
"#\n"
"\n"
"alias declare=typeset\n"
"\n"
"nameref FUNCNAME=.sh.fun\n"
"\n"
"if	[[ ! $EUID ]]\n"
"then	EUID=$(id -u)\n"
"readonly EUID\n"
"fi\n"
"\n"
"if	[[ ! $UID ]]\n"
"then	UID=$(id -u)\n"
"readonly UID\n"
"fi\n"
"\n"
"readonly SHELLOPTS\n"
"if ! shopt -qo restricted; then\n"
"IFS=:\n"
"for i in $SHELLOPTS\n"
"do\n"
"[[ -n \"$i\" ]] && shopt -s $i\n"
"done\n"
"unset IFS\n"
"fi\n"
"function SHELLOPTS.get\n"
"{\n"
".sh.value=$(shopt -so)\n"
".sh.value=${.sh.value//+([[:space:]])on*([[:space:]])/:}\n"
".sh.value=${.sh.value%:}\n"
"}\n"
"\n"
"set -A GROUPS $(id -G)\n"
"function GROUPS.set\n"
"{\n"
"return 1\n"
"}\n"
"function GROUPS.unset\n"
"{\n"
"unset -f GROUPS.set\n"
"unset -f GROUPS.unset\n"
"}\n"
"\n"
"typeset -A DIRSTACK\n"
"function DIRSTACK.get\n"
"{\n"
"set -A .sh.value $(dirs)\n"
"}\n"
"function DIRSTACK.set\n"
"{\n"
"integer index\n"
"index=_push_max-.sh.subscript\n"
"(( index == _push_max || index < _push_top )) && return\n"
"_push_stack[index]=${.sh.value}\n"
"}\n"
"function DIRSTACK.unset\n"
"{\n"
"unset -f DIRSTACK.get\n"
"unset -f DIRSTACK.set\n"
"unset -f DIRSTACK.unset\n"
"}\n"
"\n"
"function __pwd\n"
"{\n"
"typeset pwd=$(pwd) home=~\n"
"case $pwd in\n"
"$home)          pwd=\'~\';;\n"
"$home/*)        pwd=\'~\'\"${pwd:${#home}}\";;\n"
"esac\n"
"print -r -- \"$pwd\"\n"
"}\n"
"\n"
"function PS1.get \n"
"{\n"
"eval .sh.value=$($PROMPT_COMMAND)\'$PS1\'\n"
"}\n"
"\n"
"function PS1.set \n"
"{\n"
"typeset prefix remaining=${.sh.value} var=$($PROMPT_COMMAND) n= k=\n"
"while	[[ $remaining ]]\n"
"do	prefix=${remaining%%\'\\\'*}\n"
"remaining=${remaining:${#prefix}}\n"
"var+=\"$prefix\"\n"
"case ${remaining:1:1} in\n"
"t)	var+=\"\\$(printf \'%(%H:%M:%S)T\')\";;\n"
"d)	var+=\"\\$(printf \'%(%a %b:%e)T\')\";;\n"
"n)	var+=$\'\\n\';;\n"
"s)	var+=ksh;;\n"
"w)	var+=\"\\$(__pwd)\";;\n"
"W)	var+=\"\\$(basename \\\"\\$(pwd)\\\")\";;\n"
"u)	var+=$USER;;\n"
"h)	var+=$(hostname -s);;\n"
"\'#\')	var+=!;;\n"
"!)	var+=!;;\n"
"@)	var+=\"\\$(printf \'%(%I:%M%p)T\')\";;\n"
"\'$\')	if	(( $(id -u) == 0 ))\n"
"then	var+=\'#\'\n"
"else	var+=\'$\'\n"
"fi;;\n"
"\'\\\')	var+=\'\\\\\';;\n"
"\'[\')	prefix=\'\\\\\\[*\\\\]\'\n"
"remaining=${remaining#$prefix}\n"
"continue;;\n"
"\'[\'|\']\')	;;\n"
"[0-7])	case ${remaining:1:3} in\n"
"[0-7][0-7][0-7])\n"
"k=4;;\n"
"[0-7][0-7])\n"
"k=3;;\n"
"*)	k=2;;\n"
"esac\n"
"eval n=\"\\$\'\"${remaining:0:k}\"\'\"\n"
"var+=$n\n"
"remaining=${remaining:k}\n"
"continue\n"
";;\n"
"\"\")	;;\n"
"*)	var+=\'\\\'${remaining:0:2};;\n"
"esac\n"
"remaining=${remaining:2}\n"
"done\n"
".sh.value=$var\n"
"}\n"
"function logout\n"
"{\n"
"if shopt -q login_shell; then\n"
"exit\n"
"else\n"
"print ${BASH##*/}: $0: not login shell: use \'exit\' >&2\n"
"return 1\n"
"fi\n"
"}\n"
"PS1=\"bash$ \"\n"
"\n"
"# this won\'t work when sourcpath is not set since PATH will be . while\n"
"# running the . script.  sourcpath needs to be handled in b_dotcmd.\n"
"#function source\n"
"#{\n"
"#	if ! shopt -qpo posix; then\n"
"#		unset	OPATH\n"
"#		typeset OPATH=$PATH\n"
"#		typeset PATH=$PATH\n"
"#		if shopt -q sourcepath; then\n"
"#			PATH=$OPATH:.\n"
"#		else\n"
"#			PATH=.\n"
"#		fi\n"
"#	fi\n"
"#	. \"$@\"\n"
"#}\n"
"unalias .\n"
"alias .=source\n"
"#endif\n"
"alias builtin=command\n"
"\n"
"function help\n"
"{\n"
"typeset b cmd usage try_cmd man\n"
"function has_help_option\n"
"{\n"
"[[ $1 == @(\'\'|/*|:|echo|false|true|login|test|\'[\') ]] && return 1\n"
"return 0\n"
"}\n"
"typeset -A short_use=(\n"
"[echo]=\'Usage: echo [ options ] [arg]...\'\n"
"[:]=\'Usage: : ...\'\n"
"[true]=\'Usage: true ...\'\n"
"[false]=\'Usage: false ...\'\n"
"[login]=\'Usage: login [-p] [name]\'\n"
"[\'[\']=\'Usage: [ EXPRESSION ] | [ OPTION\'\n"
"[test]=\'Usage: test EXPRESSION | test\'\n"
")\n"
"b=$(builtin)\n"
"if	(( $# == 0))\n"
"then	print \'The following is the current list of built-in commands:\'\n"
"print -r $\'Type help *name* for more information about name\\n\'\n"
"for cmd in $b\n"
"do	if	has_help_option $cmd\n"
"then	usage=$($cmd --short 2>&1)\n"
"print -r -- \"${usage:7}\"\n"
"else	print -r -- ${short_use[$cmd]:7}\n"
"fi\n"
"done\n"
"return\n"
"fi\n"
"b=${b/\'[\'/}\n"
"man=--man\n"
"[[ $1 == -s ]] && man=--short && shift\n"
"for try_cmd\n"
"do	if	has_help_option $try_cmd\n"
"then	if	[[ $try_cmd == @(${b//$\'\\n\'/\'|\'}) ]]\n"
"then	$try_cmd $man\n"
"else	man $try_cmd\n"
"fi\n"
"elif	[[ $man == \'--short\' ]]\n"
"then	print -r -- ${short_use[$try_cmd]}\n"
"else	man $try_cmd\n"
"fi\n"
"done\n"
"}\n"
"\n"
"function cd\n"
"{\n"
"local msg\n"
"local args\n"
"local i\n"
"local a\n"
"local ret\n"
"\n"
"if ! shopt -q cdable_vars; then\n"
"command cd \"$@\"\n"
"else\n"
"msg=$(command cd \"$@\" 2>&1)\n"
"ret=$?\n"
"if [[ $ret != 0 ]]; then\n"
"for i\n"
"do\n"
"case $i in\n"
"-*)	args=\"$args $i\" ;;\n"
"*/*)	args=\"$args $i\" ;;\n"
"*)	eval a=\"$\"$i\n"
"if [[ -n $a ]]; then args=\"$args $a\"\n"
"else args=\"$args $i\"\n"
"fi\n"
";;\n"
"esac\n"
"done\n"
"\n"
"command cd $args\n"
"else\n"
"print -- $msg\n"
"return $ret\n"
"fi\n"
"fi\n"
"}\n"
"\n"
"typeset BASH=$0\n"
"! shopt -qo posix && HISTFILE=~/.bash_history\n"
"HOSTNAME=$(hostname)\n"
"nameref BASH_SUBSHELL=.sh.subshell\n"
"nameref BASH_REMATCH=.sh.match\n"
"nameref BASH_SOURCE=.sh.file\n"
;
